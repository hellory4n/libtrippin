"""
samurai: barely a build system
https://github.com/hellory4n/libtrippin

Copyright (C) 2025 by hellory4n <hellory4n@gmail.com>

Permission to use, copy, modify, and/or distribute this
software for any purpose with or without fee is hereby
granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS
ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
"""

import os
import sys
from dataclasses import dataclass
from collections.abc import Callable
from warnings import warn

@dataclass
class Project:
	name: str
	compiler: str
	cflags: str
	"flags passed during compilation"

	ldflags: str
	"flags passed during linking"

	sources: list[str]
	"list of source files"

	target: str | None
	"name of the final executable, defaults to the project name"

	prebuild: Callable[[]] | None
	"function to run before building"

	postbuild: Callable[[]] | None
	"function to run after building"

_options: dict[str, Callable[[str]]]
_option_descriptions: dict[str, str]
_project: Project | None

# Returns the version. No shit.
def version() -> str:
	return "v0.2.0"

# Adds a CLI option. The callback is called if the option is used.
def option(name: str, description: str, callback: Callable[[str]]) -> None:
	global _options, _option_descriptions
	_options[name] = callback
	_option_descriptions[name] = description

def project(proj: Project) -> None:
	global _project

	# required fields
	if proj.name == "":
		raise ValueError("the project needs a name you doofus")
	if proj.compiler == "":
		raise ValueError("the project needs a compiler you doofus")
	if len(proj.sources) == 0:
		raise ValueError("you have no source files you doofus")

	# optional fields
	if proj.target == None:
		proj.target = proj.name
	if proj.prebuild == None:
		proj.prebuild = lambda: None # python this is braindead syntax
	if proj.postbuild == None:
		proj.postbuild = lambda: None

	_project = proj

def _cmd_help() -> None:
	global _option_descriptions
	sys.stdout.write(
f"""The samurai build system
Usage: ./{__file__} [command] [options...]

Commands:
   help: shows this
   configure: creates the ninja build script
   build: builds the project
   clean: removes all build files
   version: prints the samurai + lua version
""")

	if len(_option_descriptions) > 0:
		sys.stdout.write("\nOptions: (usage: name=value)\n")

		# mmm yes i love sorting oh yeah oughhh im sorting its all over hte screen
		for option, description in sorted(_options.items()):
			sys.stdout.write(f"    {option}: {description}\n")

def _cmd_configure(proj: Project) -> None:
	with open("build.ninja", "w") as f:
		f.write(f"# Autogenerated by samurai. You probably shouldn't edit this.\n")
		f.write(f"cc = {proj.compiler}\n")
		f.write(f"cflags = {proj.cflags}\n")
		f.write(f"ldflags = {proj.ldflags}\n")

		f.write(f"\nrule compile\n")
		f.write(f"  command = $cc $cflags -c $in -o $out\n")
		f.write(f"  description = Compiling $in\n")

		f.write(f"\nrule link\n")
		f.write(f"  command = $cc $in $ldflags -o $out\n")
		f.write(f"  description = Linking $out\n\n")

		for src in proj.sources:
			f.write(f"build build/obj/{(src + ".o").replace('/', '_')}: compile {src}\n")

		f.write(f"\nbuild build/bin/{proj.target}: link ")
		for src in proj.sources:
			f.write(f"build/obj/{(src + ".o").replace('/', '_')} ")

		f.write(f"\n\ndefault build/bin/{proj.target}\n")

	# get the compile_commands.json
	assert os.system("ninja -t compdb > compile_commands.json") == 0

def _cmd_build(proj: Project) -> None:
	if os.path.isfile("build.ninja"):
		raise Exception("no build.ninja file found, please create one with the 'configure' command")

	# make sure the build dirs exist
	assert os.system("mkdir build/obj -p") == 0
	assert os.system("mkdir build/bin -p") == 0

	if proj.prebuild != None: proj.prebuild()
	if os.system("ninja") != 0:
		raise Exception("build failed :(")
	if proj.postbuild != None: proj.postbuild()

	sys.stdout.write("build succeeded!\n")

def _cmd_clean() -> None:
	# scary!
	assert os.system("rm -rf build/**") == 0
	assert os.system("rm -f build.ninja") == 0
	assert os.system("rm -f .ninja_log") == 0

def _cmd_version() -> None:
	sys.stdout.write(f"samurai {version()}, using Python v{sys.version}")

def init() -> None:
	pass # TODO

def run() -> None:
	global _options
	if _project == None:
		raise Exception("please set a project with 'samurai.project()'")

	options: dict[str, str] = {}

	# argv[0] is the filename, argv[1] is the command
	for arg in sys.argv[2:]:
		strs = arg.split('=', 2)
		if len(strs) == 1:
			raise Exception("expected value (rtfm dumbass)")

		options[strs[0]] = strs[1]

	# im having an aneurysm:)
	for option, value in options.items():
		if option in _options.keys():
			_options[option](value)
		else:
			warn(f"unknown option '{option}'")

	# argv[1] is the command
	match sys.argv[1]:
		case "help" | "--help" | "-h":
			_cmd_help()
		case "configure":
			_cmd_configure(_project)
		case "build":
			_cmd_build(_project)
		case "clean":
			_cmd_clean()
		case "version" | "--version" | "-v":
			_cmd_version()
		case _:
			raise Exception(
				f"invalid command '{sys.argv[1]}' (try 'help' to see available commands")
