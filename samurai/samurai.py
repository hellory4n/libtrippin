"""
samurai: barely a build system
https://github.com/hellory4n/libtrippin

Copyright (C) 2025 by hellory4n <hellory4n@gmail.com>

Permission to use, copy, modify, and/or distribute this
software for any purpose with or without fee is hereby
granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS
ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO
EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
USE OR PERFORMANCE OF THIS SOFTWARE.
"""

import os
import sys
from dataclasses import dataclass
from collections.abc import Callable

@dataclass
class Project:
	name: str
	compiler: str
	cflags: str
	"flags passed during compilation"

	ldflags: str
	"flags passed during linking"

	sources: list[str]
	"list of source files"

	target: str | None = None
	"name of the final executable, defaults to the project name"

	prebuild: Callable[[], None] | None = None
	"function to run before building"

	postbuild: Callable[[], None] | None = None
	"function to run after building"

_option_descriptions: dict[str, str] = {}
_project: Project | None = None

# Returns the version. No shit.
def version() -> str:
	return "v0.2.0"

# Adds a CLI option, and returns the value if it's used
def option(name: str, description: str) -> str | None:
	global _option_descriptions
	_option_descriptions[name] = description

	# TODO this sucks
	# argv[0] is the filename, argv[1] is the command
	for arg in sys.argv[2:]:
		strs = arg.split('=', maxsplit=2)
		if len(strs) == 1:
			raise Exception("cli arguments seem to be busted (rtfm dumbass)")

		if strs[0] == name:
			return strs[1]

	return None

def project(proj: Project) -> None:
	global _project

	# required fields
	if proj.name == "":
		raise ValueError("the project needs a name you doofus")
	if proj.compiler == "":
		raise ValueError("the project needs a compiler you doofus")
	if len(proj.sources) == 0:
		raise ValueError("you have no source files you doofus")

	# optional fields
	if proj.target == None:
		proj.target = proj.name
	if proj.prebuild == None:
		proj.prebuild = lambda: None # python this is braindead syntax
	if proj.postbuild == None:
		proj.postbuild = lambda: None

	_project = proj

def _cmd_help() -> None:
	global _option_descriptions
	sys.stdout.write(
f"""The samurai build system
Usage: {sys.argv[0]} [command] [options...]

Commands:
    help: shows this
    configure: creates the ninja build script
    build: builds the project
    clean: removes all build files
    version: prints the samurai + python version
""")

	if len(_option_descriptions) > 0:
		sys.stdout.write("\nOptions: (usage: name=value)\n")

		# mmm yes i love sorting oh yeah oughhh im sorting its all over hte screen
		for option, description in sorted(_option_descriptions.items()):
			sys.stdout.write(f"{' ' * 4}{option}: {description}\n")

def _cmd_configure(proj: Project) -> None:
	with open("build.ninja", "w") as f:
		f.write(f"# Autogenerated by samurai. You probably shouldn't edit this.\n")
		f.write(f"cc = {proj.compiler}\n")
		f.write(f"cflags = {proj.cflags}\n")
		f.write(f"ldflags = {proj.ldflags}\n")

		f.write(f"\nrule compile\n")
		f.write(f"  command = $cc $cflags -c $in -o $out\n")
		f.write(f"  description = Compiling $in\n")

		f.write(f"\nrule link\n")
		f.write(f"  command = $cc $in $ldflags -o $out\n")
		f.write(f"  description = Linking $out\n\n")

		for src in proj.sources:
			f.write(f"build build/obj/{(src + ".o").replace('/', '_')}: compile {src}\n")

		f.write(f"\nbuild build/bin/{proj.target}: link ")
		for src in proj.sources:
			f.write(f"build/obj/{(src + ".o").replace('/', '_')} ")

		f.write(f"\n\ndefault build/bin/{proj.target}\n")

	# get the compile_commands.json
	assert os.system("ninja -t compdb > compile_commands.json") == 0

def _cmd_build(proj: Project) -> None:
	if not os.path.isfile("build.ninja"):
		raise Exception("no build.ninja file found, please create one with the 'configure' command")

	# just in case
	os.makedirs("build/obj", exist_ok=True)
	os.makedirs("build/bin", exist_ok=True)

	if proj.prebuild != None: proj.prebuild()
	if os.system("ninja") != 0:
		sys.stdout.write("build failed :(\n")
		exit(1)
	if proj.postbuild != None: proj.postbuild()

def _cmd_clean() -> None:
	# scary!
	# TODO theres probably a python function for this
	assert os.system("rm -rf build/**") == 0
	# assert os.system("rm -f build.ninja") == 0
	assert os.system("rm -f .ninja_log") == 0

def _cmd_version() -> None:
	sys.stdout.write(f"samurai {version()}, using Python v{sys.version}\n")

def run() -> None:
	global _options
	if _project == None:
		raise Exception("please set a project with 'samurai.project()'")

	if len(sys.argv) == 1:
		_cmd_help()
		return

	# argv[1] is the command
	match sys.argv[1]:
		case "help" | "--help" | "-h":
			_cmd_help()
		case "configure":
			_cmd_configure(_project)
		case "build":
			_cmd_build(_project)
		case "clean":
			_cmd_clean()
		case "version" | "--version" | "-v":
			_cmd_version()
		case _:
			raise Exception(
				f"invalid command '{sys.argv[1]}' (try 'help' to see available commands")
